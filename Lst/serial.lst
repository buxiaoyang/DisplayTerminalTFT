C51 COMPILER V7.50   SERIAL                                                                02/19/2014 22:52:49 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE SERIAL
OBJECT MODULE PLACED IN .\Obj\serial.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Src\serial.c COMPACT BROWSE INCDIR(.\Src) DEBUG OBJECTEXTEND PRINT(.\Lst\se
                    -rial.lst) OBJECT(.\Obj\serial.obj)

line level    source

   1          /************************************************************/
   2          /*项目：DisplayTerminalTFT
   3          /*模块：串口模块
   4          /*日期：2014年2月17日
   5          /*修改：卜晓D
   6          /************************************************************/
   7          
   8          #include "reg52stc.h"
   9          #include "serial.h"
  10          
  11          
  12          /******************** 显示数据缓存 *******************/
  13          
  14          //年     月  日  时      分       状态  服务  cpu    内存    上传      下载      温度    IP地址
  15          //0123   45      67      9 10  12 13       15    17       19 20  22 23  25 26 27   29 30 31      33 34   36~50
  16          uchar DisplayData[51] = "20140219,13:26,N,N,45,64,034,089,13,192.168.025.001";
  17          uchar DisplayDataTemp[51] = "20140219,13:26,N,N,45,64,034,089,13,192.168.025.001";
  18          //数据格式 BGI20140219,13:26,N,N,45,64,034,089,13,192.168.025.001STO
  19          
  20          /******************** 全局变量定义 *******************/
  21          uchar get_i=0;  //读取数据的计数
  22          uchar LenToSend=0;
  23          uint DataToSend;
  24          #define    RELOAD_COUNT    0xe6    //12MHz,0xf3, 12T,SMOD=0,2400bps; 24MHz 0xe6
  25          #define    Self_Define_ISP_Download_Command    0x7f
  26          
  27          uchar readSerialCurrent = 0;
  28          uchar readSerialNumber = 0;
  29          uint readSerialTimeOut = 0; 
  30          /******************** 延迟函数ms *******************/
  31          void delayms(uint tt)
  32          {
  33   1          uchar i;
  34   1              uchar j;
  35   1          while(tt>0)
  36   1          {
  37   2              tt--;
  38   2              for(j=0;j<5;j++)
  39   2                  {
  40   3                          for(i=0;i<168;i++)
  41   3                              {
  42   4                              }
  43   3              }
  44   2          }
  45   1      }
  46          
  47          
  48          /******************** 串口数据处理函数 *******************/
  49          void readSerialProcess(uchar input)
  50          {
  51   1              uchar i;
  52   1              switch(readSerialCurrent)
  53   1              {
  54   2                      case 0:
C51 COMPILER V7.50   SERIAL                                                                02/19/2014 22:52:49 PAGE 2   

  55   2                              if(input == 'B')
  56   2                                      readSerialCurrent ++;
  57   2                      break;  
  58   2                      case 1:
  59   2                              if(input == 'G')
  60   2                                      readSerialCurrent ++;   
  61   2                              else
  62   2                                      readSerialCurrent = 0;
  63   2                      break;  
  64   2                      case 2:
  65   2                              if(input == 'I')
  66   2                              {
  67   3                                      readSerialCurrent ++;
  68   3                                      readSerialNumber = 0;   
  69   3                              }
  70   2                              else
  71   2                                      readSerialCurrent = 0;  
  72   2                      break; 
  73   2                      case 3:  //read serial
  74   2                              DisplayDataTemp[readSerialNumber] = input;
  75   2                              readSerialNumber ++;    
  76   2                              if(input == 'S')
  77   2                                      readSerialCurrent ++;
  78   2                              if(readSerialNumber > 52)
  79   2                                      readSerialCurrent = 0;
  80   2                      break;
  81   2                      case 4:
  82   2                              if(input == 'T')
  83   2                                      readSerialCurrent ++;   
  84   2                              else
  85   2                                      readSerialCurrent = 0;
  86   2                      case 5:
  87   2                              if(input == 'O')
  88   2                                      readSerialCurrent ++;   
  89   2                              else
  90   2                                      readSerialCurrent = 0;
  91   2                      case 6:
  92   2                              for(i=0; i<51; i++)
  93   2                              {
  94   3                                      DisplayData[i] = DisplayDataTemp[i];    
  95   3                              }
  96   2                              readSerialTimeOut = 0;
  97   2                              readSerialCurrent = 0;  
  98   2                      break;
  99   2                      default:
 100   2                              readSerialCurrent = 0;
 101   2              }
 102   1      }
 103          
 104          /******************** 软复位函数 *******************/
 105          void soft_reset_to_ISP_Monitor(void)
 106          {
 107   1              IAP_CONTR = 0x60;   //0110，0000  软复位到系统ISP监控区
 108   1      }
 109          
 110          /******************** 串口接收中断函数 *******************/
 111          void UART_Interrupt_Receive(void) interrupt 4 //using 1
 112          {
 113   1              uchar k;
 114   1              if(RI==1)
 115   1              {
 116   2                      RI = 0;
C51 COMPILER V7.50   SERIAL                                                                02/19/2014 22:52:49 PAGE 3   

 117   2                      k = SBUF;
 118   2                      if((k==Self_Define_ISP_Download_Command)||(0x1f==k))        //是自定义下载命令
 119   2                      {
 120   3                              get_i++;
 121   3                              if (10==get_i)
 122   3                              {
 123   4                                      delayms(200); //zxy
 124   4                                      soft_reset_to_ISP_Monitor();    //软复位到系统ISP监控区
 125   4                              }
 126   3                      }
 127   2                      else
 128   2                      {
 129   3                              if ((0==TI)&&(0==LenToSend))
 130   3                              {
 131   4                                      SBUF=0xa5;  //Serial OK !!!
 132   4                              }
 133   3                              get_i=0;
 134   3                      }
 135   2                      readSerialProcess(k);
 136   2              }
 137   1              else
 138   1              {
 139   2                      TI = 0;
 140   2                      if (0!=LenToSend)
 141   2                      {
 142   3                              LenToSend--;
 143   3                              if (0==LenToSend)
 144   3                                      SBUF=DataToSend>>8;
 145   3                              else
 146   3                                      SBUF=DataToSend;
 147   3                      }
 148   2              }       
 149   1      }
 150          
 151          /******************** 串口发送函数 *******************/
 152          void SerialSend(uint Data, uchar Len)
 153          {
 154   1              if (0==TI)
 155   1              {
 156   2                      SBUF=Data;
 157   2                      Len--;
 158   2              }
 159   1              LenToSend=Len;
 160   1              DataToSend=Data;
 161   1      }
 162          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    347    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =    110    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
