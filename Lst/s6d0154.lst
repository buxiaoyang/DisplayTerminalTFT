C51 COMPILER V7.50   S6D0154                                                               02/15/2014 12:33:08 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE S6D0154
OBJECT MODULE PLACED IN .\Obj\s6d0154.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Src\s6d0154.c BROWSE INCDIR(.\Src) DEBUG OBJECTEXTEND PRINT(.\Lst\s6d0154.l
                    -st) OBJECT(.\Obj\s6d0154.obj)

line level    source

   1          #include <reg52.h>
   2          #include"head.h"        //IO define
   3          
   4          #include"s6d0154_drv.h" //包含_24TFT-OK的正确初始化程序  
   5          
   6          #include"picture.h"
   7          #include"chinese.h"
   8          #include"char.h"
   9          //------------------------------------------------------------------
  10          uint colors[]={
  11          //   0      1      2      3      4      5      6      7
  12          0xf800,0x07e0,0x001f,0xffe0,0x0000,0x07ff,0xf81f,0xffff  //颜色数据
  13          //  红     绿     蓝     黄     黑     青     紫     白
  14          };
  15          //******************************************************************
  16          //  
  17          //------------------------------------------------------------------
  18          void delayms(long tt)
  19          {
  20   1          while(tt>0)
  21   1          {
  22   2              tt--;
  23   2          }
  24   1      }
  25          /*
  26          void delay(long tt)
  27          {
  28              while(tt>0)
  29              {
  30                  tt--;
  31              }
  32          }
  33          */
  34          void Write_DATA(unsigned int i,unsigned int j)
  35          {
  36   1          //8080 interface
  37   1          LCD_CS = 0;
  38   1              LCD_DC = 1;
  39   1              LCD_RD = 1;
  40   1              P0  = j;
  41   1              P2  = i;
  42   1              LCD_WR = 0;
  43   1              LCD_WR = 1;
  44   1              LCD_CS = 1;
  45   1      }
  46          /*
  47          void Write_DAT_18(unsigned int i,unsigned int j,unsigned int k)
  48          {
  49              //8080 interface
  50              CS0 = 0;
  51                  DC0 = 1;
  52                  RD0 = 1;
  53                  P2  = i;
  54                  P0  = j;
C51 COMPILER V7.50   S6D0154                                                               02/15/2014 12:33:08 PAGE 2   

  55                  WR0 = 0;
  56                  WR0 = 1;
  57                  P2  = k;
  58                  WR0 = 0;
  59                  WR0 = 1;
  60                  CS0 = 1;
  61          }
  62          */
  63          void Write_COMD(unsigned int i,unsigned int j)
  64          {
  65   1              //8080 interface
  66   1          LCD_CS = 0;  
  67   1          LCD_RD = 1;
  68   1          LCD_DC = 0;
  69   1              P0  = j;         
  70   1              P2  = i;
  71   1              LCD_WR = 0;
  72   1              LCD_WR = 1;
  73   1              LCD_CS = 1;
  74   1      }
  75          //******************************************************************
  76          //  分颜色显示
  77          //------------------------------------------------------------------
  78          void Display_Red(void)
  79          {  
  80   1          int i,j,k=0;
  81   1           
  82   1          Write_COMD(0x00,0x20);
  83   1          Write_DATA(0x00,0x00);        
  84   1          Write_COMD(0x00,0x21);
  85   1          Write_DATA(0x00,0x00);   
  86   1              
  87   1          Write_COMD(0x00,0x22); 
  88   1          for(i=0;i<320;i++)
  89   1          {
  90   2              for(j=0;j<240;j++)
  91   2                  {
  92   3                  Write_DATA(0xf8,0x00);//data_out18(0xfc,0x00,0x00);
  93   3                  }
  94   2          }
  95   1      }
  96          void Display_Green(void)
  97          {  
  98   1          int i,j;
  99   1         
 100   1          Write_COMD(0x00,0x20);
 101   1          Write_DATA(0x00,0x00);        
 102   1          Write_COMD(0x00,0x21);
 103   1          Write_DATA(0x00,0x00);        
 104   1         
 105   1          Write_COMD(0x00,0x22); 
 106   1          for(i=0;i<320;i++)
 107   1          {
 108   2              for(j=0;j<240;j++)
 109   2                  {
 110   3                  Write_DATA(0x07,0xe0);
 111   3                  //Write_Data_18(0x03,0xf0,0x00);
 112   3              }
 113   2          }
 114   1      }
 115          void Display_Blue(void)
 116          {  
C51 COMPILER V7.50   S6D0154                                                               02/15/2014 12:33:08 PAGE 3   

 117   1          int i,j;
 118   1           
 119   1          Write_COMD(0x00,0x20);
 120   1          Write_DATA(0x00,0x00);
 121   1          Write_COMD(0x00,0x21);
 122   1          Write_DATA(0x00,0x00);
 123   1         
 124   1          Write_COMD(0x00,0x22);
 125   1          for(i=0;i<320;i++)
 126   1          {
 127   2                  for(j=0;j<240;j++)
 128   2              {
 129   3                          Write_DATA(0x00,0x1f);
 130   3                  //Write_Data_18(0x00,0x0f,0xc0);
 131   3              }
 132   2          }
 133   1      }
 134          void Display_White(void)
 135          {
 136   1          int i,j;
 137   1          
 138   1          Write_COMD(0x00,0x22);
 139   1          for(i=0;i<320;i++)
 140   1          {
 141   2              for(j=0;j<240;j++)
 142   2                  {
 143   3                  Write_DATA(0xff,0xff);
 144   3                  //Write_Data_18(0xff,0xff,0xc0);
 145   3              }
 146   2          }
 147   1      }
 148          void Display_Black(void)
 149          {  
 150   1          int i,j,k;
 151   1           
 152   1          Write_COMD(0x00,0x22);
 153   1          for(i=0;i<240;i++)
 154   1          {
 155   2              Write_DATA(0xff,0xff);
 156   2              //Write_DATA_18(0xff,0xff,0xc0);
 157   2          }
 158   1          //---------------------------------
 159   1          for(i=0;i<318;i++)  //加外框
 160   1          {
 161   2              for(k=0;k<1;k++)
 162   2                  {
 163   3                  Write_DATA(0xff,0xff);
 164   3                      //WRITE_DATA_18(0xff,0xff,0xc0);
 165   3                  }
 166   2                  for(j=0;j<238;j++)
 167   2                  {
 168   3                          Write_DATA(0x00,0x00);
 169   3                          //Write_DATA_18(0x00,0x00,0x00);
 170   3                  }
 171   2                  for(k=0;k<1;k++)
 172   2                  {
 173   3                      Write_DATA(0xff,0xff);
 174   3                  //Write_DATA_18(0xff,0xff,0xc0);
 175   3                  }
 176   2          }
 177   1          //---------------------------------
 178   1          for(i=0;i<240;i++)
C51 COMPILER V7.50   S6D0154                                                               02/15/2014 12:33:08 PAGE 4   

 179   1          {
 180   2              Write_DATA(0xff,0xff);
 181   2              //Write_Data_18(0xff,0xff,0xc0);
 182   2          }
 183   1      }
 184          //******************************************************************
 185          //  图片显示(仅240*80dot模式)
 186          //------------------------------------------------------------------
 187          void Display_Image(void)
 188          {
 189   1          unsigned int i=0,j=0,t=0;
 190   1         
 191   1          Write_COMD(0x00,0x22);
 192   1          for(t=0;t<4;t++)  //显示4次->填满240x320空间
 193   1          {
 194   2              unsigned int  k=0;
 195   2              
 196   2              for(i=0;i<240;i++)
 197   2              {
 198   3                  for(j=0;j<80;j++)
 199   3                  {
 200   4                      Write_DATA(Image[k++],Image[k++]);
 201   4                  }
 202   3              }
 203   2          }
 204   1      }
 205          //******************************************************************
 206          //  
 207          //------------------------------------------------------------------
 208          void LCD_Writ_Bus(char VH,char VL)      //并行数据写入函数
 209          {
 210   1          LCD_DataPortH=VH;     //高位P口
 211   1              LCD_DataPortL=VL;         //低位P口     
 212   1              LCD_WR=0;
 213   1              LCD_WR=1; 
 214   1      }
 215          void LCD_Write_COM(char VH,char VL)         //发送命令
 216          {       
 217   1          LCD_DC=0;
 218   1              LCD_Writ_Bus(VH,VL);
 219   1      }
 220          void LCD_Write_DATA(char VH,char VL)    //发送数据
 221          {
 222   1          LCD_DC=1;
 223   1              LCD_Writ_Bus(VH,VL);
 224   1      }
 225          //******************************************************************
 226          //  
 227          //------------------------------------------------------------------
 228          void Pant(char VH,char VL)
 229          {
 230   1              int i,j;
 231   1              
 232   1              LCD_CS =0;  //打开片选使能
 233   1              Address_set(0,0,239,319);
 234   1          for(i=0;i<320;i++)
 235   1              {
 236   2              for (j=0;j<240;j++)
 237   2              {
 238   3                  LCD_Write_DATA(VH,VL);
 239   3                  }
 240   2          }
C51 COMPILER V7.50   S6D0154                                                               02/15/2014 12:33:08 PAGE 5   

 241   1          LCD_CS =1;  //关闭片选使能
 242   1      }
 243          void Address_set(unsigned int x1,unsigned int y1,unsigned int x2,unsigned int y2)
 244          {
 245   1      
 246   1          LCD_Write_COM(0x00,0x20);LCD_Write_DATA(x1>>8,x1);  //设置X坐标位置
 247   1          LCD_Write_COM(0x00,0x21);LCD_Write_DATA(y1>>8,y1);  //设置Y坐标位置
 248   1                       
 249   1          LCD_Write_COM(0x00,0x37);LCD_Write_DATA(x1>>8,x1);  //开始X
 250   1              LCD_Write_COM(0x00,0x39);LCD_Write_DATA(y1>>8,y1);  //开始Y
 251   1          LCD_Write_COM(0x00,0x36);LCD_Write_DATA(x2>>8,x2);  //结束X
 252   1              LCD_Write_COM(0x00,0x38);LCD_Write_DATA(y2>>8,y2);  //结束Y
 253   1      
 254   1              LCD_Write_COM(0x00,0x22);                                                                                
 255   1      }
 256          //******************************************************************
 257          //  写汉字子函数
 258          //------------------------------------------------------------------
 259          void ChineseChar(uint x,uint y,int size,uint For_color,uint Bk_color ,char c)
 260          {
 261   1          int e=0,i,j;
 262   1          int  ed;
 263   1         
 264   1          uint  ncols;
 265   1          uint  nrows;
 266   1          uint  nbytes;
 267   1      
 268   1          uchar *pfont;
 269   1          uchar *pchar;
 270   1          uchar *fonttable[]={(uchar *)hz16,(uchar *)hz24 , (uchar *)hz32};
 271   1         
 272   1          pfont=(uchar *)fonttable[size];
 273   1      
 274   1          if(size==0)
 275   1          {
 276   2              ncols =16-1;
 277   2              nrows =16-1;
 278   2              nbytes =32;      //(16*16)/8
 279   2          }
 280   1          else
 281   1          {    
 282   2              if(size==1)
 283   2              {
 284   3                  ncols =24-1;
 285   3                  nrows =24-1;
 286   3                  nbytes =72;  //(24*24)/8
 287   3              }
 288   2              else
 289   2              {
 290   3                  if(size==2)
 291   3                  {
 292   4                      ncols =32-1;
 293   4                      nrows =32-1;
 294   4                      nbytes =132;   //(32*32)/8
 295   4                  }
 296   3              }
 297   2          }
 298   1          pchar=pfont + (nbytes*(c-1));
 299   1      
 300   1          Address_set(x,  y, x+nrows,y+ncols);
 301   1          //---------------------------------
 302   1          for(i=0;i<nbytes;i++)
C51 COMPILER V7.50   S6D0154                                                               02/15/2014 12:33:08 PAGE 6   

 303   1          {
 304   2              ed=*pchar++;
 305   2              if(size==0)
 306   2              {
 307   3                  if(i%2==0)
 308   3                      e=8;
 309   3                  else
 310   3                      e=4;
 311   3              }
 312   2              else
 313   2                  e=8;
 314   2              for(j=0;j<e;j++)
 315   2              {//unsigned char temp;
 316   3                  if((ed>>j)&0x01)
 317   3                  { 
 318   4                     //temp = For_color&0x00ff
 319   4                         LCD_Write_DATA(For_color>>8 , For_color  );  //textcolor
 320   4                      }
 321   3                  else
 322   3                  {
 323   4                      LCD_Write_DATA( Bk_color>>8 ,  Bk_color);  //backcolor
 324   4                      }
 325   3              }
 326   2          }
 327   1      }
 328          //******************************************************************
 329          //  字符显示子函数
 330          //------------------------------------------------------------------
 331          void LCD_ShowChar(uint x,uint y,uint For_color,uint Bk_color, char ch)
 332          {       
 333   1          uchar temp , Bytes;
 334   1          uchar pos,t;
 335   1          uint  CHAR_W,CHAR_H;
 336   1         
 337   1          //CHAR_W = 8;         //8*16
 338   1          //CHAR_H = 16;
 339   1      
 340   1          CHAR_W = 16;         //16*24
 341   1          CHAR_H = 24;
 342   1      
 343   1          if(x>(LCD_SIZE_X-CHAR_W)||y>(LCD_SIZE_Y-CHAR_H))
 344   1              return;
 345   1         
 346   1          Address_set(x, y, x+CHAR_W-1, y+CHAR_H-1);
 347   1          ch = ch-32;                       //按照ASCII编码顺序的到相应字母的编码
 348   1          Bytes = (CHAR_W*CHAR_H)/8;
 349   1          for(pos=0;pos<Bytes;pos++)  //CHAR_H        (CHAR_W*CHAR_H)/8
 350   1          {
 351   2              //temp= Font8x16[ch][pos];
 352   2              //temp= Font16x24[ch][pos];
 353   2              temp= Font16x24[ch][pos];
 354   2            
 355   2              for(t=0;t<8;t++) //CHAR_W
 356   2              {                 
 357   3                     if(temp&0x80)
 358   3                         LCD_Write_DATA(For_color>>8 , For_color  );  //textcolor
 359   3                     else 
 360   3                         LCD_Write_DATA(Bk_color>>8 , Bk_color );  //backcolor
 361   3                  temp<<=1; 
 362   3              }
 363   2          }
 364   1      }  
C51 COMPILER V7.50   S6D0154                                                               02/15/2014 12:33:08 PAGE 7   

 365          //******************************************************************
 366          //  显示字符串子函数    x,y:起点坐标    *p:字符串起始地址
 367          //------------------------------------------------------------------
 368          void LCD_ShowString(uint x,uint y,uint For_color,uint Bk_color,char *p)
 369          {         
 370   1          while(*p!='\0')
 371   1          {       
 372   2              LCD_ShowChar(x,y,For_color,Bk_color,*p);
 373   2              //x+=8;
 374   2              x+=16;
 375   2              p++;
 376   2          }
 377   1      }
 378          //******************************************************************
 379          //  
 380          //------------------------------------------------------------------
 381          void LCD_Init(void)
 382          {
 383   1          LCD_RST=1;
 384   1          delayms(5);
 385   1              LCD_RST=0;
 386   1              delayms(5);
 387   1              LCD_RST=1;
 388   1              delayms(5);
 389   1              LCD_CS =0;  //打开片选使能
 390   1          //---------------------------------
 391   1              LCD_Write_COM(0x00,0x10); LCD_Write_DATA(0x00,0x00);  // Power Control 1  current consumption  STB
 392   1              delayms(10);
 393   1              
 394   1              LCD_Write_COM(0x00,0x11); LCD_Write_DATA(0x00,0x1c);  // Power Control 2
 395   1              LCD_Write_COM(0x00,0x12); LCD_Write_DATA(0x12,0x12);  // Power Control 3  BT2-0, DC11-10, DC21-20, DC31-3
             -0
 396   1              LCD_Write_COM(0x00,0x13); LCD_Write_DATA(0x00,0x41);  // Power Control 4  DCR_EX=0, DCR2-0, GVD6-0
 397   1              LCD_Write_COM(0x00,0x14); LCD_Write_DATA(0x40,0x50);  // Power Control 5  VCOMG=0, VCM6-0, VCMR=0, VML6-0
 398   1              LCD_Write_COM(0x00,0x10); LCD_Write_DATA(0x08,0x00);  // Power Control 1 
 399   1              LCD_Write_COM(0x00,0x11); LCD_Write_DATA(0x01,0x1c);  // Power Control 2
 400   1              delayms(300);//300ms
 401   1              LCD_Write_COM(0x00,0x11); LCD_Write_DATA(0x03,0x1c);  // Power Control 2
 402   1              delayms(300);//300ms
 403   1              LCD_Write_COM(0x00,0x11); LCD_Write_DATA(0x07,0x1c);  // Power Control 2
 404   1              delayms(300);//300ms
 405   1              LCD_Write_COM(0x00,0x11); LCD_Write_DATA(0x0f,0x1c);  // Power Control 2
 406   1              delayms(40);//600ms
 407   1              LCD_Write_COM(0x00,0x11); LCD_Write_DATA(0x0f,0x39);  // Power Control 2
 408   1              delayms(60);//500ms
 409   1              LCD_Write_COM(0x00,0x01); LCD_Write_DATA(0x01,0x28);  // Driver Output Control
 410   1              LCD_Write_COM(0x00,0x02); LCD_Write_DATA(0x01,0x00);  // LCD-Driving-Waveform Control
 411   1              LCD_Write_COM(0x00,0x03); LCD_Write_DATA(0x10,0x30);  // Entry Mode
 412   1              LCD_Write_COM(0x00,0x08); LCD_Write_DATA(0x08,0x08);  // Frame Cycle Control 
 413   1              LCD_Write_COM(0x00,0x0b); LCD_Write_DATA(0x11,0x05);  // Frame Cycle Control
 414   1              LCD_Write_COM(0x00,0x0c); LCD_Write_DATA(0x00,0x00);  // External Display Interface Control 
 415   1          //---------------------------------
 416   1          LCD_Write_COM(0x00,0x15); LCD_Write_DATA(0x00,0x20);  //VCI Recycling (R15H)                //              VCIR=010         0X0020
 417   1              LCD_Write_COM(0x00,0x30); LCD_Write_DATA(0x00,0x00);  //                SCN 0   Start from G1
 418   1              LCD_Write_COM(0x00,0x34); LCD_Write_DATA(0x01,0x3f);  //                SE1 = 100111111( 319)
 419   1              LCD_Write_COM(0x00,0x35); LCD_Write_DATA(0x00,0x00);  //                SS1 = 000000000
 420   1              LCD_Write_COM(0x00,0x36); LCD_Write_DATA(0x00,0xef);  //                HEA = 011101111(239)
 421   1              LCD_Write_COM(0x00,0x37); LCD_Write_DATA(0x00,0x00);  //                HSA = 000000000 
 422   1              LCD_Write_COM(0x00,0x38); LCD_Write_DATA(0x01,0x3f);  //                VEA = 100111111( 319)
 423   1          LCD_Write_COM(0x00,0x39); LCD_Write_DATA(0x00,0x00);  //            VSA = 000000000 
 424   1          LCD_Write_COM(0x00,0x50); LCD_Write_DATA(0x01,0x01);  // Gamma Control
 425   1          //---------------------------------
C51 COMPILER V7.50   S6D0154                                                               02/15/2014 12:33:08 PAGE 8   

 426   1              LCD_Write_COM(0x00,0x51); LCD_Write_DATA(0x09,0x03);
 427   1              LCD_Write_COM(0x00,0x52); LCD_Write_DATA(0x0b,0x08);
 428   1              LCD_Write_COM(0x00,0x53); LCD_Write_DATA(0x08,0x05);
 429   1              LCD_Write_COM(0x00,0x54); LCD_Write_DATA(0x01,0x01);
 430   1              LCD_Write_COM(0x00,0x55); LCD_Write_DATA(0x0d,0x06);
 431   1              LCD_Write_COM(0x00,0x56); LCD_Write_DATA(0x0e,0x0a);
 432   1              LCD_Write_COM(0x00,0x57); LCD_Write_DATA(0x01,0x00);
 433   1              LCD_Write_COM(0x00,0x58); LCD_Write_DATA(0x1f,0x0b);
 434   1              LCD_Write_COM(0x00,0x59); LCD_Write_DATA(0x02,0x01);
 435   1              //---------------------------------
 436   1              LCD_Write_COM(0x00,0x20); LCD_Write_DATA(0x00,0x00);  //Set RAM Address
 437   1              LCD_Write_COM(0x00,0x21); LCD_Write_DATA(0x00,0x00);  //Set RAM Address
 438   1              //0x22            RAM Data Write
 439   1              //LCD_CtrlWrite(0x0022);
 440   1              LCD_Write_COM(0x00,0x0f); LCD_Write_DATA(0x1f,0x01);  // Start Oscillation
 441   1              delayms(300);//300ms
 442   1              LCD_Write_COM(0x00,0x07); LCD_Write_DATA(0x00,0x16);  // Display Control
 443   1              delayms(32);//200ms
 444   1              LCD_Write_COM(0x00,0x07); LCD_Write_DATA(0x00,0x17);
 445   1              //---------------------------------
 446   1              LCD_CS =1;
 447   1      }
 448          //******************************************************************
 449          //  
 450          //------------------------------------------------------------------
 451          
 452          
 453          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1878    ----
   CONSTANT SIZE    =  47569    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     16      83
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
