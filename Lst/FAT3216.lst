C51 COMPILER V7.50   FAT3216                                                               02/15/2014 14:32:22 PAGE 1   


C51 COMPILER V7.50, COMPILATION OF MODULE FAT3216
OBJECT MODULE PLACED IN .\Obj\FAT3216.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE Src\FAT3216.C BROWSE INCDIR(.\Src) DEBUG OBJECTEXTEND PRINT(.\Lst\FAT3216.l
                    -st) OBJECT(.\Obj\FAT3216.obj)

line level    source

   1          /*****************************************************************************
   2          
   3                                   FAT3216 文件系统51裁剪版
   4                                (仅支持根目录文件搜索与读取)
   5          
   6          *****************************************************************************/
   7          
   8          #include "STC_NEW_8051.H"
   9          #include "SD_MMC.h"
  10          #include "FAT3216.h"
  11          #include "s6d0154_drv.h"
  12          #include "head.h"
  13          
  14          LongByte  File_length, Next_cluster;
  15          LongByte Addr;                   //SD卡数据物理地址
  16          unsigned char gSector_count; //扇区计数器
  17          unsigned char FatType;
  18          unsigned int BPB_RootEntCnt;
  19          unsigned char xdata Buffer[512];
  20          
  21          unsigned long FAT_base;
  22          unsigned long Dat_base;
  23          
  24          unsigned char Cluster_size;
  25          unsigned char Shift_bits;
  26          //#define Cluster_size TH1
  27          //#define Shift_bits   TL1
  28          //char data * xdata str;         /* ptr in xdata to data char */
  29          //int xdata * data numtab;       /* ptr in data to xdata int */
  30          //long code * idata powtab;      /* ptr in idata to code long */
  31          
  32          unsigned char idata BufferChar[16];
  33          unsigned char idata* HEXtoASCL(unsigned long HEX, unsigned char index, unsigned char len)
  34          {
  35   1        unsigned char i, j, temp;
  36   1        unsigned int tempi;
  37   1        if ((0==len)||((index+len)>15))
  38   1        {
  39   2          BufferChar[0]=0;
  40   2          return BufferChar;  
  41   2        }
  42   1        i=len&3;
  43   1        j=(len)>>2;
  44   1        if (!i)
  45   1        {
  46   2          j--;
  47   2              i=4;
  48   2        }
  49   1        if (j)
  50   1          tempi=(unsigned int)(HEX>>16);
  51   1        else
  52   1          tempi=HEX;
  53   1        do
  54   1        {
C51 COMPILER V7.50   FAT3216                                                               02/15/2014 14:32:22 PAGE 2   

  55   2          for (;i!=0;i--)
  56   2          {
  57   3            if (4==i)
  58   3                  temp=tempi>>12;
  59   3            else if (3==i)
  60   3                  temp=tempi>>8;
  61   3            else if (2==i)
  62   3                  temp=tempi>>4;
  63   3                else
  64   3                  temp=tempi;
  65   3                temp&=0x0f;
  66   3                if (temp>9)
  67   3                  BufferChar[index]=temp+'A'-10;
  68   3                else
  69   3                  BufferChar[index]=temp+'0';
  70   3                index++;
  71   3          }
  72   2              i=4;
  73   2          tempi=HEX;
  74   2        }while(0!=j--);
  75   1        BufferChar[index]=0;
  76   1        return BufferChar;    
  77   1      }
  78          
  79          unsigned char HalftoASC(unsigned char half)
  80          {
  81   1        unsigned char i='0';
  82   1        if (half>9)
  83   1          i = 'A';
  84   1      //  else 
  85   1      //    half += '0';
  86   1        return half+i;
  87   1      }
  88          
  89          /******************************** 获取磁盘参数 ******************************/
  90          unsigned char Get_disk_info(void)
  91          {
  92   1          unsigned int  Reserved;     //保留区
  93   1          unsigned char Signature;    //启动扇区标识符
  94   1          unsigned char i, res;
  95   1      
  96   1      /*    LCD_CS =0;  //打开片选使能
  97   1          Addr.all = 0x12345678;
  98   1          HEXtoASCL(Addr.all,0, 1);
  99   1              LCD_ShowString(0,0,colors[0],colors[4], BufferChar);
 100   1          HEXtoASCL(Addr.all,0, 2);
 101   1              LCD_ShowString(112,0,colors[1],colors[4], BufferChar);
 102   1          HEXtoASCL(Addr.all,0, 3);
 103   1              LCD_ShowString(0,24,colors[2],colors[4], BufferChar);
 104   1          HEXtoASCL(Addr.all,0, 4);
 105   1              LCD_ShowString(112,24,colors[3],colors[4], BufferChar);
 106   1          HEXtoASCL(Addr.all,0, 5);
 107   1              LCD_ShowString(0,48,colors[4],colors[7], BufferChar);
 108   1          HEXtoASCL(Addr.all,0, 6);
 109   1              LCD_ShowString(112,48,colors[5],colors[4], BufferChar);
 110   1          HEXtoASCL(Addr.all,0, 7);
 111   1              LCD_ShowString(0,72,colors[6],colors[4], BufferChar);
 112   1          HEXtoASCL(Addr.all,0, 8);
 113   1              LCD_ShowString(112,72,colors[7],colors[4], BufferChar);
 114   1      */    res=0;
 115   1          Addr.all = 0;               //指向0号扇区
 116   1          SD_send_read_cmd();         //发送读取指令
C51 COMPILER V7.50   FAT3216                                                               02/15/2014 14:32:22 PAGE 3   

 117   1          Wait_start_token();         //等待SD卡响应
 118   1      
 119   1          Signature = SD_read_byte();  //读取首字节
 120   1          SD_read_byte();              //跳过1节字节
 121   1          Skip_nwords(222);           //跳过444字节
 122   1      
 123   1          if (Signature == 0xeb)      //是否为跳指令"0xeb"
 124   1          {                           //如是，判断为DBR扇区
 125   2              Skip_nwords(0x20);      //空读64字节
 126   2          }
 127   1          else                        //否则判断为MBR引导扇区
 128   1          {
 129   2              i = 4;                  //最多为4个分区
 130   2              while(1)                //顺序搜索4个分区信息
 131   2              {
 132   3                  Read_nbytes(0x10);  //读取16字节分区信息
 133   3                  if (Buffer[8] | Buffer[9])         //如不为零，信息有效
 134   3                  {
 135   4                      Addr.byte[0] = Buffer[11];     //获取分区起始扇区号
 136   4                      Addr.byte[1] = Buffer[10];
 137   4                      Addr.byte[2] = Buffer[9];
 138   4                      Addr.byte[3] = Buffer[8];     
 139   4      //    HEXtoASCL(Addr.all,0);
 140   4      //      LCD_ShowString(0,0,colors[2],colors[4], BufferChar);
 141   4                      Addr.all = Addr.all << 9;      //转换为地址
 142   4      //    HEXtoASCL(Addr.all,0);
 143   4      //      LCD_ShowString(0,24,colors[2],colors[4], BufferChar);
 144   4                      while(--i) Read_nbytes(0x10);  //空读剩余字节
 145   4                      break; 
 146   4                  }
 147   3                  else
 148   3                  {
 149   4                      if(--i == 0)
 150   4                                      {
 151   5                                        Error(6);        //未找到分区信息，报错
 152   5                                        res=1;
 153   5                                      }
 154   4                  }
 155   3              }
 156   2          }
 157   1      
 158   1          Signature = SD_read_byte();                 //读取最后两字节
 159   1              i =     SD_read_byte();
 160   1          SD_read_block_complete();                  //结束一次块读操作
 161   1              if (res) return res;
 162   1          if (i != 0xaa || Signature != 0x55)        //最后两字节应为0x55aa
 163   1              {
 164   2                Error(6);
 165   2                res=2;
 166   2                return res;
 167   2              }
 168   1      
 169   1          //---------------------- 读取DBR扇区进行处理 ---------------------------
 170   1          SD_send_read_cmd();                           //发送读取指令
 171   1          Wait_start_token();                           //等待SD卡响应
 172   1          Read_nbytes(64);                              //读取64字节
 173   1      
 174   1          //------------------ 分析扇区结构是否符合FAT32规范 ---------------------
 175   1          if (Buffer[0] != 0xeb)
 176   1              {
 177   2                Error(7);              //跳转指令0xeb
 178   2                res=3;
C51 COMPILER V7.50   FAT3216                                                               02/15/2014 14:32:22 PAGE 4   

 179   2              }
 180   1          if (Buffer[0x0c] != 0x02 ||
 181   1              Buffer[0x0b] != 0x00 ||                   //扇区大小为应为512字节
 182   1      //        Buffer[0x2c] != 0x02 ||                   //根目录簇号应为2
 183   1      //       (Buffer[0x2d]|Buffer[0x2e]|Buffer[0x2f]) != 0 || 
 184   1              Buffer[0x10] != 0x02 ||                //FAT表应为两个
 185   1              Buffer[0x0d] == 0x00)           //每簇扇区数不能为0
 186   1               {
 187   2                 Error(8);
 188   2                 res=4;
 189   2               }
 190   1          //-------------------------- 保存有用的信息 ----------------------------
 191   1          Cluster_size = Buffer[0x0d];
 192   1          Reserved = Buffer[0x0e] + (Buffer[0x0f]<<8);  //保留区扇区数
 193   1          FAT_base = Addr.all + (Reserved<<9);          //FAT基址 = DBR基址 + 保留区大小
 194   1      
 195   1              for(Shift_bits = 9; (Buffer[0x0d] & 1) == 0; Shift_bits++) Buffer[0x0d] >>= 1;
 196   1                                                        //计算簇号转为地址时需要移位次数
 197   1          if (Buffer[0x16] == 0x00 &&
 198   1              Buffer[0x17] == 0x00)
 199   1              {
 200   2            FatType=1;
 201   2                BPB_RootEntCnt=(Buffer[0x12]<<8)|Buffer[0x11];
 202   2                File_length.byte[0] = Buffer[0x27];           //获取每个FAT占用的扇区数(最高字节为0)
 203   2            File_length.byte[1] = Buffer[0x26];
 204   2            File_length.byte[2] = Buffer[0x25];
 205   2            File_length.byte[3] = Buffer[0x24];
 206   2      //      Dat_base = FAT_base + (File_length.all << 10);//根目录地址 = FAT基址 + 两个FAT大小
 207   2      //      Dat_base -= 2ul << Shift_bits;                            //由于簇号从2算起，把数据区起始地址向前移2簇
 208   2              }
 209   1              else
 210   1              {
 211   2            FatType=0;
 212   2            File_length.byte[0] = 0;           //获取每个FAT占用的扇区数(最高字节为0)
 213   2            File_length.byte[1] = 0;
 214   2            File_length.byte[2] = Buffer[0x17];
 215   2            File_length.byte[3] = Buffer[0x16];
 216   2                BPB_RootEntCnt=(Buffer[0x12]<<8)|Buffer[0x11];
 217   2                File_length.all+=     (BPB_RootEntCnt>>5);              //两个sector大小
 218   2      //      Dat_base = FAT_base + (File_length.all << 10);//根目录地址 = FAT基址 + 两个FAT大小
 219   2      //      Dat_base -= 2ul << Shift_bits;                            //由于簇号从2算起，把数据区起始地址向前移2簇
 220   2              }                
 221   1          Dat_base = FAT_base + (File_length.all << 10);//根目录地址 = FAT基址 + 两个FAT大小
 222   1          Dat_base -= 2ul << Shift_bits;                                //由于簇号从2算起，把数据区起始地址向前移2簇
 223   1          LCD_CS =0;  //打开片选使能
 224   1      //    HEXtoASCL(FAT_base,0);
 225   1      //      LCD_ShowString(0,72,colors[2],colors[4], BufferChar);
 226   1          HEXtoASCL(Dat_base,0,8);
 227   1              LCD_ShowString(0,96,colors[2],colors[4], BufferChar);
 228   1      
 229   1          Skip_nwords(223);                             //略过446字节
 230   1          Signature = SD_read_byte();                    //检测最后两字节应为0x55aa
 231   1          if (SD_read_byte() != 0xaa || Signature != 0x55) Error(7);
 232   1          SD_read_block_complete();                     //结束一次块读操作
 233   1          LCD_CS =0;  //打开片选使能
 234   1          LCD_ShowString(0,296,colors[7],colors[4],"Get disk in OK!");
 235   1          LCD_CS =1;  //关闭片选使能
 236   1              return res;
 237   1      }
 238          
 239          /***************************** 搜查根目录中的文件 ****************************/
 240          unsigned char Scan_file(unsigned char n, unsigned char File_type)
C51 COMPILER V7.50   FAT3216                                                               02/15/2014 14:32:22 PAGE 5   

 241          {
 242   1          unsigned char Cluster_count;
 243   1          unsigned char Sector_count;
 244   1          unsigned char i,j,k;
 245   1          unsigned char code NameExt[] =            
 246   1          {
 247   1              " TXTBIN"                  
 248   1          };
 249   1      
 250   1      //    LCD_CS =0;  //打开片选使能
 251   1      //    LCD_ShowString(0,272,colors[0],colors[4],"Scaning file...");
 252   1          for (k = 3; k != 0; k--)                //预载文件名于Buffer，以便进行比较
 253   1          {
 254   2              Buffer[k + 2] = ' ';
 255   2              Buffer[k + 5] = ' ';
 256   2              Buffer[k + 7] = NameExt[File_type+k]; //
 257   2              Buffer[k - 1] = (n%10)+'0';          //依次载入个十百位的ASC码
 258   2              n = n / 10;                         //十进制右移一位
 259   2          }
 260   1              Buffer[11]=0;  
 261   1          LCD_CS =0;  //打开片选使能
 262   1          LCD_ShowString(0,272,colors[2],colors[4],Buffer);
 263   1      
 264   1          Cluster_count = 100;                    //限制根目录搜索深度，防止数据错误导致死读
 265   1              Next_cluster.all = 2;                   //根目录从簇号2开始
 266   1          if (FatType)
 267   1              {
 268   2      //        Next_cluster.all = 2;                   //根目录从簇号2开始
 269   2            gSector_count =   Cluster_size;
 270   2              }
 271   1              else
 272   1              {
 273   2            gSector_count =   32;
 274   2      //        Next_cluster.all = 0;                   //根目录从簇号2开始
 275   2                Next_cluster.all -= (unsigned char)(BPB_RootEntCnt>>4)/Cluster_size;
 276   2              }
 277   1              do                                      //按簇链依次进行文件搜索
 278   1          {
 279   2              Sector_count = 0;
 280   2              Addr.all = Dat_base + (Next_cluster.all << Shift_bits); //计算簇基址
 281   2              do                                  //搜索簇内各个扇区
 282   2              {  
 283   3          LCD_ShowChar(208,272,colors[2],colors[4], HalftoASC(Cluster_count>>4));
 284   3          LCD_ShowChar(224,272,colors[2],colors[4], HalftoASC(Cluster_count&15));
 285   3                  SD_send_read_cmd();             //发送读取指令
 286   3          HEXtoASCL(Addr.all,0,8);
 287   3              LCD_ShowString(0,248,colors[2],colors[4], BufferChar);
 288   3                  Addr.all += 512;                //计算下一扇区地址
 289   3      //    LCD_ShowString(0,224,colors[0],colors[4],"Wait token...");
 290   3                  Wait_start_token();             //等待SD卡响应
 291   3                  for (j = 16; j != 0; j--)       //搜索扇区内各个文件记录
 292   3                  {   
 293   4                      for (i = 0; i != 12; i++)   //比较文件名的11个字符
 294   4                      {                           //只比较文件名前三位数字和扩展名，其它忽略
 295   5                          if (SD_read_byte() != Buffer[i] && (i & 0x07) < 3) break;
 296   5                      }
 297   4                       
 298   4                      if (i == 12)                                  //匹配成功
 299   4                      {
 300   5                          Cluster_count = 0;                        //清零簇计数器，标记搜索完成
 301   5                          Read_nbytes(20);                          //获取文件记录信息
 302   5                          Next_cluster.byte[0] = Buffer[0x15-12];   //获取文件的起始簇号
C51 COMPILER V7.50   FAT3216                                                               02/15/2014 14:32:22 PAGE 6   

 303   5                          Next_cluster.byte[1] = Buffer[0x14-12];
 304   5                          Next_cluster.byte[2] = Buffer[0x1b-12];
 305   5                          Next_cluster.byte[3] = Buffer[0x1a-12];
 306   5      //                    if (!FatType)
 307   5      //                                        Next_cluster.all--;
 308   5                                              Addr.all = Dat_base + (Next_cluster.all << Shift_bits);//计算得文件的起始地址
 309   5                                              gSector_count = Cluster_size;        //扇区计数器初始化
 310   5      //                    if (!FatType)
 311   5      //                                        Next_cluster.all++;
 312   5      
 313   5                          File_length.byte[0] = Buffer[0x1f-12];    //获取文件的长度
 314   5                          File_length.byte[1] = Buffer[0x1e-12];
 315   5                          File_length.byte[2] = Buffer[0x1d-12];
 316   5                          File_length.byte[3] = Buffer[0x1c-12];
 317   5                          File_length.all = File_length.all >> 9;   //计算文件占用的扇区数量
 318   5      
 319   5                          while(--j) Skip_nwords(16);               //读完一扇区的剩余字节
 320   5                          break;
 321   5                      }
 322   4                      else                                          //匹配不成功，则略过剩余字节
 323   4                      {
 324   5                          i = 31 - i;
 325   5                          do
 326   5                          {
 327   6                               SD_read_byte();
 328   6                          }
 329   5                          while(--i);
 330   5                      }
 331   4                  }
 332   3                  SD_read_block_complete();                         //结束一次块读操作
 333   3      
 334   3                  if (Cluster_count == 0)
 335   3                              {
 336   4          LCD_CS =0;  //打开片选使能
 337   4          HEXtoASCL(Addr.all,0,8);
 338   4              LCD_ShowString(0,224,colors[1],colors[4], BufferChar);
 339   4          LCD_ShowString(0,200,colors[7],colors[4],"Scan file OK!");
 340   4          LCD_CS =1;  //关闭片选使能
 341   4                                return 0;                 //搜索成功，返回
 342   4                              }
 343   3              }
 344   2              while(++Sector_count != gSector_count);                //继续搜索簇内下一扇区
 345   2      
 346   2              if (!FatType)
 347   2                        return 1;
 348   2                      else
 349   2                      {
 350   3                        //------------------------- 根据簇链取得下一簇号 ------------------------------
 351   3                Set_block_size(0);                                    //设定SD卡块大小为4字节
 352   3                if (FatType)
 353   3                          Next_cluster.all = Next_cluster.all << 1;
 354   3                        Addr.all = FAT_base + (Next_cluster.all << 1);        //根据簇链计算链表地址
 355   3                SD_send_read_cmd();                                   //发送读取指令
 356   3      //    LCD_ShowString(0,224,colors[2],colors[4],"Wait token...");
 357   3                Wait_start_token();                                   //等待SD卡响应
 358   3                Next_cluster.byte[3] = SD_read_byte();//获取下一簇簇号
 359   3                Next_cluster.byte[2] = SD_read_byte();
 360   3                Next_cluster.byte[1] = SD_read_byte();
 361   3                Next_cluster.byte[0] = SD_read_byte();
 362   3                SD_read_block_complete();             //结束一次块读操作
 363   3      
 364   3                Set_block_size(1);                    //重新设定SD卡块大小为512字节
C51 COMPILER V7.50   FAT3216                                                               02/15/2014 14:32:22 PAGE 7   

 365   3      //          if (FatType)
 366   3                        {
 367   4                          if (( Next_cluster.byte[3]            //判断是否为簇链结束标志 0x0fffffff
 368   4                    & Next_cluster.byte[2]
 369   4                    & Next_cluster.byte[1]) == 0xff
 370   4                    && Next_cluster.byte[0]  == 0x0f)
 371   4                    break;
 372   4                        }
 373   3      /*                else
 374   3                        {
 375   3                  Next_cluster.byte[1] = 0;
 376   3                  Next_cluster.byte[0] = 0;
 377   3                          if (( Next_cluster.byte[3]            //判断是否为簇链结束标志 0xffff
 378   3                    & Next_cluster.byte[2]) == 0xff)
 379   3                    break;
 380   3                        }
 381   3      */              }
 382   2          }
 383   1          while(--Cluster_count != 0);              //循环搜索下一簇，直至达到最大数目
 384   1          return 1;
 385   1      }
 386          
 387          
 388          unsigned char Readfile(void)
 389          {
 390   1        unsigned char xdata * pBuffer;
 391   1        unsigned char i, j;
 392   1      
 393   1        //------------------- 发送扇区读取命令 -----------------
 394   1        SD_send_read_cmd();
 395   1        //-------------------- 读取一扇区数据 ---------------------
 396   1        Wait_start_token();         //等待SD卡响应
 397   1        pBuffer=Buffer;
 398   1        for (j=2; j!=0; j--)   //读取512字节
 399   1        {
 400   2          i=0;
 401   2              do
 402   2              {
 403   3                *pBuffer = SD_read_byte();
 404   3                pBuffer++;
 405   3                i--;
 406   3              }while(i!=0);
 407   2        }
 408   1        SD_read_block_complete();                     //结束一次块读操作
 409   1          LCD_CS =0;  //打开片选使能
 410   1          LCD_ShowString(0,192,colors[1],colors[4],"Read file OK!");
 411   1          LCD_CS =1;  //关闭片选使能
 412   1      
 413   1                  //------------------- 计算下一扇区地址 --------------------
 414   1                  if (--gSector_count != 0)
 415   1                  {                           //如在同一簇内
 416   2                      Addr.all += 512;        //则下一扇区地址增加512
 417   2                  }
 418   1                  else                        //否则要查找下一簇地址
 419   1                  {
 420   2                      Set_block_size(0);                            //设定SD卡块大小为4字节
 421   2                      if (FatType)
 422   2                                Next_cluster.all = Next_cluster.all << 1;
 423   2                                      Addr.all = FAT_base + (Next_cluster.all << 1);//根据簇链计算链表地址
 424   2                      SD_send_read_cmd();                           //发送读取指令
 425   2                      gSector_count = Cluster_size;                  //扇区计数器重置
 426   2                      Wait_start_token();                           //等待SD卡响应
C51 COMPILER V7.50   FAT3216                                                               02/15/2014 14:32:22 PAGE 8   

 427   2                      Next_cluster.byte[3] = SD_read_byte();        //获取下一簇簇号
 428   2                      Next_cluster.byte[2] = SD_read_byte();
 429   2                      Next_cluster.byte[1] = SD_read_byte();
 430   2                      Next_cluster.byte[0] = SD_read_byte();
 431   2                      SD_read_block_complete();                     //结束一次块读操作
 432   2                                      if (!FatType)
 433   2                                      {
 434   3                        Next_cluster.byte[1] = 0;
 435   3                        Next_cluster.byte[0] = 0;
 436   3                                      }
 437   2                      Addr.all = Dat_base + (Next_cluster.all << Shift_bits);//计算下一簇地址
 438   2      
 439   2                      Set_block_size(1);                            //重新设定SD卡块大小为512字节
 440   2      
 441   2                      if (FatType)
 442   2                                      {
 443   3                        if (( Next_cluster.byte[3]                    //判断是否为簇链结束标志 0x0fffffff
 444   3                            & Next_cluster.byte[2]
 445   3                            & Next_cluster.byte[1]) == 0xff
 446   3                           && Next_cluster.byte[0]  == 0x0f)
 447   3                          {return 0;}
 448   3                                      }                               //如果是，返回1
 449   2                              else
 450   2                              {
 451   3                                if (( Next_cluster.byte[3]            //判断是否为簇链结束标志 0xffff
 452   3                          & Next_cluster.byte[2]) == 0xff)
 453   3                          return 0;
 454   3                              }
 455   2                  }                                                 
 456   1                  File_length.all--;                                //文件长度递减
 457   1                  if ((File_length.byte[1]                          //判断文件读完
 458   1                     | File_length.byte[2]                          
 459   1                     | File_length.byte[3]) == 0)                   
 460   1                     {return 2;}                                                                      //如果是，返回2
 461   1        return 0;                                
 462   1      }
 463          /*
 464          unsigned char Disp_TFImage(void)
 465          {
 466          //  unsigned char xdata * pBuffer;
 467            unsigned char i;
 468            unsigned int k;
 469          
 470              LCD_CS =0;  //打开片选使能
 471              HEXtoASCL(Addr.all,0,8);
 472                  LCD_ShowString(0,296,colors[0],colors[4], BufferChar);
 473              LCD_ShowString(0,192,colors[1],colors[4],"Reading file...");
 474                  LCD_CS =0;  //打开片选使能
 475                  Address_set(0,0,239,319);
 476              LCD_DC=1;
 477          
 478            for (k=300; k!=0; k--)   //读取300 * 512字节
 479            {
 480            //------------------- 发送扇区读取命令 -----------------
 481            SD_send_read_cmd();
 482            //-------------------- 读取一扇区数据 ---------------------
 483            Wait_start_token();         //等待SD卡响应
 484            i=0;
 485          //    pBuffer=Buffer;
 486          //      do
 487          //      {
 488          //        *pBuffer = SD_read_byte();
C51 COMPILER V7.50   FAT3216                                                               02/15/2014 14:32:22 PAGE 9   

 489          //        pBuffer++;
 490          //        *pBuffer = SD_read_byte();
 491          //        pBuffer++;
 492          //        i--;
 493          //      }while(i!=0);
 494          //    pBuffer=Buffer;
 495                  do
 496                  {
 497                LCD_WR = 0;
 498          //      P2 = SD_read_byte();
 499          //      P2 = *pBuffer;
 500          //        pBuffer++;
 501          //      P0 = SD_read_byte();
 502          //      P2 = *pBuffer;
 503          //        pBuffer++;
 504           #pragma asm
 505                          clr CLK
 506                          mov c, MISO
 507                          setb CLK
 508                          rlc A
 509                          clr CLK
 510                          mov c, MISO
 511                          setb CLK
 512                          rlc A
 513                          clr CLK
 514                          mov c, MISO
 515                          setb CLK
 516                          rlc A
 517                          clr CLK
 518                          mov c, MISO
 519                          setb CLK
 520                          rlc A
 521                          clr CLK
 522                          mov c, MISO
 523                          setb CLK
 524                          rlc A
 525                          clr CLK
 526                          mov c, MISO
 527                          setb CLK
 528                          rlc A
 529                          clr CLK
 530                          mov c, MISO
 531                          setb CLK
 532                          rlc A
 533                          clr CLK
 534                          mov c, MISO
 535                          setb CLK
 536                          rlc A
 537                          mov P2, A
 538          
 539                          clr CLK
 540                          mov c, MISO
 541                          setb CLK
 542                          rlc A
 543                          clr CLK
 544                          mov c, MISO
 545                          setb CLK
 546                          rlc A
 547                          clr CLK
 548                          mov c, MISO
 549                          setb CLK
 550                          rlc A
C51 COMPILER V7.50   FAT3216                                                               02/15/2014 14:32:22 PAGE 10  

 551                          clr CLK
 552                          mov c, MISO
 553                          setb CLK
 554                          rlc A
 555                          clr CLK
 556                          mov c, MISO
 557                          setb CLK
 558                          rlc A
 559                          clr CLK
 560                          mov c, MISO
 561                          setb CLK
 562                          rlc A
 563                          clr CLK
 564                          mov c, MISO
 565                          setb CLK
 566                          rlc A
 567                          clr CLK
 568                          mov c, MISO
 569                          setb CLK
 570                          rlc A
 571                          mov P0, A
 572          #pragma endasm
 573                LCD_WR = 1;
 574                    i--;
 575                  }while(i!=0);
 576              SD_read_block_complete();                     //结束一次块读操作
 577          //    LCD_CS =0;  //打开片选使能
 578          //    LCD_ShowString(0,192,colors[1],colors[4],"Read file OK!");
 579          //    LCD_CS =1;  //关闭片选使能
 580          
 581                      //------------------- 计算下一扇区地址 --------------------
 582                      if (--gSector_count != 0)
 583                      {                           //如在同一簇内
 584                          Addr.all += 512;        //则下一扇区地址增加512
 585                      }
 586                      else                        //否则要查找下一簇地址
 587                      {
 588                          Set_block_size(0);                            //设定SD卡块大小为4字节
 589                          if (FatType)
 590                                    Next_cluster.all = Next_cluster.all << 1;
 591                                          Addr.all = FAT_base + (Next_cluster.all << 1);//根据簇链计算链表地址
 592                          SD_send_read_cmd();                           //发送读取指令
 593                          Addr.all = Dat_base + (Next_cluster.all << Shift_bits);//计算下一簇地址
 594                          gSector_count = Cluster_size;                  //扇区计数器重置
 595                          Wait_start_token();                           //等待SD卡响应
 596                          Next_cluster.byte[3] = SD_read_byte();        //获取下一簇簇号
 597                          Next_cluster.byte[2] = SD_read_byte();
 598                          Next_cluster.byte[1] = SD_read_byte();
 599                          Next_cluster.byte[0] = SD_read_byte();
 600                          SD_read_block_complete();                     //结束一次块读操作
 601          
 602                          Set_block_size(1);                            //重新设定SD卡块大小为512字节
 603                          if (FatType)
 604                                          {
 605                            if (( Next_cluster.byte[3]                    //判断是否为簇链结束标志 0x0fffffff
 606                                & Next_cluster.byte[2]
 607                                & Next_cluster.byte[1]) == 0xff
 608                               && Next_cluster.byte[0]  == 0x0f)
 609                              {return 0;}
 610                                          }                               //如果是，返回1
 611                                  else
 612                                  {
C51 COMPILER V7.50   FAT3216                                                               02/15/2014 14:32:22 PAGE 11  

 613                            Next_cluster.byte[1] = 0;
 614                            Next_cluster.byte[0] = 0;
 615                                    if (( Next_cluster.byte[3]            //判断是否为簇链结束标志 0xffff
 616                              & Next_cluster.byte[2]) == 0xff)
 617                              return 0;
 618                                  }
 619                      }                                                 
 620                      File_length.all--;                                //文件长度递减
 621                      if ((File_length.byte[1]                          //判断文件读完
 622                         | File_length.byte[2]                          
 623                         | File_length.byte[3]) == 0)                   
 624                         {return 2;}                                                                      //如果是，返回2
 625            }
 626            return 0;                                
 627          }
 628          */


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1887    ----
   CONSTANT SIZE    =     52    ----
   XDATA SIZE       =    512    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     26      19
   IDATA SIZE       =     16    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
